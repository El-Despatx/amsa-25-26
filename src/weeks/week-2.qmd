---
subtitle: "Week 2: Linux syscalls, processes and ProcFS"
format: revealjs
---

# Goals for today

-   Any questions from the previous session?
-   Learn how the CPU reacts to external input.
-   Understand how we interact with the kernel and ProcFS.
-   Present and explain Prac-2.1

# Recap

Lorem ipsum

# Interrupts

## How the CPU works
- The CPU does instruction, one at a time, [with the fetch decode execute cycle](https://www.youtube.com/watch?v=ctjnYgCo8Bc).
- [You can simulate a sum here](https://www.bit-machine.co.uk/machine.html): 

![](figures/week-2/instructions.png){fig-align="center" width=80%}

## Devices interactions with the CPU {.smaller}

-  But wait, how can we interact with external devices? We don't have the instructions on our code!

::::::: columns
:::: {.column .fragment width="50%"}
The devices connected to your computer, use a mechanism called ["interrupts"](https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html) for being aware of the events.

::: callout-warning
This is a super-summarized path (and incorrect one), there's no PIC controller, the IRQ numbers probably are wrong. But it's only for academic purposes.
:::

::::

:::: {.column .fragment width="50%"}
![](figures/week-2/keyboard_interrupt.excalidraw.png){fig-align="center" width=80%}
![](figures/week-2/idt_cpu.excalidraw.png){fig-align="center" width=80%}
::::

:::::::


## We didn't configure the IDT table...

-    Well, yes, one of the [first steps of the kernel](https://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-2.html) is to tell the cpu to point the IDT table to his part of the code that has the logic for the IDT table.

-    So, now, when we receive an interrupt is the kernel code the one that will be executed! Nice!

::: {.callout-tip .fragment}
You can see the IDT table inside the [linux kernel source code](https://elixir.bootlin.com/linux/v6.11/source/arch/x86/include/asm/irq_vectors.h#L14
), and where [it is setup](https://elixir.bootlin.com/linux/v6.16.4/source/arch/x86/kernel/idt.c#L194).
:::

## Did we get it?
- It is **very important** to understand (at a concept level) interrupts, so we can understand further things in this session (and course)
- Did we get it?
- Sure?
- Really really sure?

# User-Space and Kernel-Space

## CPU Protection {.smaller}

::::::: columns
:::: {.column .fragment width="50%"}
- The CPU allows multiple levels of "security", called rings.
- Each ring (starting from ring 0) restrict access to certain instructions.
- Linux uses the ring 0 (do "whatever you want" ring) as the Kernel Space and ring 4 (the ring where you're most limited) as UserSpace (where your programs run).

::: {.callout-warning .fragment}
Due to restricted access to memory and I/O ports in Ring 4, userspace can do almost nothing to the outside world without calling on the kernel. It can't open files, send network packets, print to the screen, or allocate memory.

But, I can do a lot of stuff with my userspace programs... How is that possible?
:::
::::

:::: {.column .fragment width="50%"}
![](figures/week-2/rings.png){fig-align="center"}

::::
:::::::

## Syscalls {.smaller}
- Well, we can write to files, so.... **we're executing some code in ring 0**.
- We execute code in ring 0 asking the kernel if can do the job for us, and then return the result.
- This request is a concept named ["syscall"](https://linux-kernel-labs.github.io/refs/heads/master/lectures/syscalls.html) (system call).

::: {.callout-tip .fragment}
You can see all the linux kernel syscalls [on this list](https://filippo.io/linux-syscall-table/)
:::

## Example {.smaller}
::::::: columns
:::: {.column .fragment width="50%"}
This python code:
``` {.python code-line-numbers="true"}
file = open("test.txt", mode='r')
lines = file.readlines()
print(lines)
```
::::

:::: {.column .fragment width="50%"}
This, under the hood, does the following:
![](figures/week-2/example.excalidraw.png){fig-align="center" width=100%}
::::

::: {.callout-tip .fragment}
You can see the system calls the program is doing under the hood, with the [strace tool](https://strace.io/)
:::

:::::::


## What are syscalls (really) {.smaller}
::::::: columns
:::: {.column .fragment width="50%"}
- We need to switch to ring 0 and there's no instruction for this, so we have to ""
- Syscalls are a certain type of interrupt (if you see the linux kernel IDT table, the number 128 one [^1]).
- So yes, the 128 entry in the IDT redirects to a function that analyzes the system call, and execute the kernel function related to it.
- For example, if we want to execute the `open` system call, we could, in userspace:

    ``` {.asm code-line-numbers="true"}
    mov	edx,4		; message length
    mov	ecx,msg		; message to write
    mov	ebx,1		; file descriptor (stdout)
    mov	eax,4		; system call number (sys_write)
    int	0x80		; call kernel, switch to ring 0
    ```
::::


:::: {.column .fragment width="50%"}
![](figures/week-2/example_syscall.excalidraw.png){fig-align="center" width=70%}
::::

:::::::


::: {.callout-tip .fragment}
Since the Linux Kernel 2.6, it supports the syscall instruction instead of doing an interrupt 128 (0x80) for syscalls. You can [read more here](
https://scribe.rip/@sachinrajakaruna95/exploring-the-evolution-of-system-call-mechanisms-in-linux-from-int-0x80-to-syscall-e133bb5c151a)
:::

[^1]: 0x80 in hex

## Brief summary {.smaller}

- The CPU **executes instructions linearly**, one after another.

- To interact with the outside world, **it relies on interrupts**.

- The CPU has different **privilege levels, called rings**, which help the operating system enforce security and control. **Our programs usually run in the least privileged ring (user mode)**, which means we can't execute certain instructions directly.

- **If we want to perform I/O operations or access system resources, we need to ask the kernel to do it for us**.

- We communicate with the kernel through **system calls (syscalls)**, which are essentially a type of interrupt.

- The kernel also sets up interrupts on its own to manage processes (like pausing one, switching to another, or handling various system events.) You can [read more here](https://0xax.gitbooks.io/linux-insides/content/Interrupts/linux-interrupts-9.html).


# Processes, threads, and kthreads

- For "abstracting" different execution concepts, the kernel has the concept of a ["task"](https://linux-kernel-labs.github.io/refs/heads/master/lectures/processes.html#lecture-objectives).

- Depending of the type of task, we can differentiate between:
    - [Kthreads](https://dengking.github.io/Linux-OS/Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4.2-Kernel-Threads/): Tasks that are done within the kernel 
    - Processes: Tasks that have a program behind, example: execute in a shell `cat /etc/passwd`
    - User-Threads: Tasks that have a different execution path from the original program (thread).

- All of this type of tasks, can be created with the [`clone`](https://www.man7.org/linux/man-pages/man2/clone.2.html) syscall.

## Kthreads

- Sometimes the kernel core or device drivers need to perform blocking operations and thus they need to run in process context.

- Kernel threads are used exactly for this and are a special class of tasks that don't "userspace" resources.

- Example: ksoftirqd/X. Where X is the number of cores. Is the scheduler kthread for this cpu on your computer.

## Processes

- The one you did at operating systems with the "fork" syscall [^1].
- A process is an operating system abstraction that groups together multiple resources:
  - An address space
  - One or more threads
  - Opened files
  - Sockets
  - Semaphores
  - Shared memory regions
  - Timers
  - Signal handlers
  - Many other resources and status information
- Example: Execute the `cat` program.

Has 

[^1] You can see the `fork` syscall as a subset of operations that the `clone` syscall can do.

## Threads

- You'll study them on `SCP`. Usually created with the glibc pthread implementation ([uses the `clone` syscall underneath](https://github.com/bminor/glibc/blob/master/sysdeps/unix/sysv/linux/x86_64/clone.S#L71)).
- A thread is the basic unit that the kernel process scheduler uses to allow applications to run the CPU. Has the following characteristics:
  - Each thread has its own stack and together with the register values it determines the thread execution state.
  - A thread runs in the context of a process and all threads in the same process share the resources.
  - The kernel schedules threads not processes and user-level threads (e.g. fibers, coroutines, etc.) are not visible at the kernel level.

- Example: If I have multiple files on the `cat` program maybe I need only different execution paths, and I can create one thread for each one.


# ProcFS

https://fernandovillalba.substack.com/p/a-journey-into-the-linux-proc-filesystem

- Finally, the thing we're doing on this assignment!
- The kernel exposes a /proc folder on the filesystem, that shows you information about the tasks running on the system.
- [`htop`](https://github.com/htop-dev/htop/blob/main/linux/LinuxProcessTable.c) is a program that embraces this, and shows you the list of tasks and properties.

<!-- - https://docs.kernel.org/filesystems/proc.html -->
<!-- - https://github.com/htop-dev/htop/issues/99 -->
<!-- - https://peteris.rocks/blog/htop/ -->

# Quizz

- The fork

- 

- 

# References

## Really Recommended References: {.smaller}

-   Example: <https://example.com>

-   Example2: <https://example2.com>


## Other recommended references:

-   https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-1.html

## Additional Exercices {.smaller}

If you really want to understand a little bit more what happens under the hood, you can do the following exercices. Be aware that you should read the "Really Recommended References" first, and then try to do this exercices.

-   Create your own syscall: [read this](https://amsa-2425.github.io/Laboratoris/Kernel/add-syscalls.html?highlight=syscall#afegint-una-crida-a-sistema) and [watch this](https://www.youtube.com/watch?v=Kn6D7sH7Fts).

## Activity 2.1 {.smaller}

Ready to have some fun? Check out the [second AMSA activity here!](/activities/act-2.qmd)
