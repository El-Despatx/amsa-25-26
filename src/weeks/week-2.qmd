---
subtitle: "Week 2: Linux syscalls, processes and ProcFS"
format: revealjs
---

# Goals for today

-   Any questions from the previous session?
-   Learn how the CPU reacts to external input.
-   Understand how we interact with the kernel and ProcFS.
-   Present and explain Prac-2.1

# Recap

Lorem ipsum

# Interrupts

## Interactions devices to CPU {.smaller}

::::::: columns
:::: {.column .fragment width="50%"}
The devices connected to your computer, use a mechanism called ["interrupts"](https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html) for being aware of the events.

::: callout-warning
This is a super-summarized path (and incorrect one), there's no PIC controller, the IRQ numbers probably are wrong. But it's only for academic purposes.
:::

::::

:::: {.column .fragment width="50%"}
![](figures/week-2/keyboard_interrupt.excalidraw.png){fig-align="center" width=80%}
![](figures/week-2/idt_cpu.excalidraw.png){fig-align="center" width=80%}
::::

:::::::


## We didn't configure the IDT table...

-    Well, yes, one of the [first steps of the kernel](https://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-2.html) is to tell the cpu to point the IDT table to his part of the code that has the logic for the IDT table.

-    So, now, when we receive an interrupt is the kernel code the one that will be executed! Nice!

::: {.callout-tip .fragment}
You can see the IDT table inside the [linux kernel source code](https://elixir.bootlin.com/linux/v6.11/source/arch/x86/include/asm/irq_vectors.h#L14
), and where [it is setup](https://elixir.bootlin.com/linux/v6.16.4/source/arch/x86/kernel/idt.c#L194).
:::

## Did we get it?
- It is **very important** to understand (at a concept level) interrupts, so we can understand further things in this session.
- Did we get it?
- Sure?
- Really really sure?

# User-Space and Kernel-Space

## CPU Protection {.smaller}

::::::: columns
:::: {.column .fragment width="50%"}
- The CPU allows multiple levels of "security", called rings.
- Each ring (starting from ring 0) restrict access to certain instructions.
- Linux uses the ring 0 (do "whatever you want" ring) as the Kernel Space and ring 4 (the ring where you're most limited) as UserSpace (where your programs run).

::: {.callout-warning .fragment}
Due to restricted access to memory and I/O ports in Ring 4, userspace can do almost nothing to the outside world without calling on the kernel. It can't open files, send network packets, print to the screen, or allocate memory.

But, I can do a lot of stuff with my userspace programs... How is that possible?
:::
::::

:::: {.column .fragment width="50%"}
![](figures/week-2/rings.png){fig-align="center"}

::::
:::::::

## Syscalls {.smaller}
- Well, we can write to files, so.... **we're executing some code in ring 0**.
- We execute code in ring 0 asking the kernel if can do the job for us, and then return the result.
- This request is a concept named ["syscall"](https://linux-kernel-labs.github.io/refs/heads/master/lectures/syscalls.html) (system call).

::: {.callout-tip .fragment}
You can see all the linux kernel syscalls [on this list](https://filippo.io/linux-syscall-table/)
:::

## Example {.smaller}
::::::: columns
:::: {.column .fragment width="50%"}
This python code:
``` {.python code-line-numbers="true"}
file = open("test.txt", mode='r')
lines = file.readlines()
print(lines)
```
::::

:::: {.column .fragment width="50%"}
This, under the hood, does the following:
![](figures/week-2/example.excalidraw.png){fig-align="center" width=100%}
::::

::: {.callout-tip .fragment}
You can see the system calls the program is doing under the hood, with the [strace tool](https://strace.io/)
:::

:::::::


## What are syscalls (really) {.smaller}
::::::: columns
:::: {.column .fragment width="50%"}
- Syscalls are a certain type of interrupt (if you see the linux kernel IDT table, the number 128 one [^1]).
- So yes, the 128 entry in the IDT redirects to a function that analyzes the system call, and execute the kernel function related to it.
- For example, if we want to execute the `open` system call, we could, in userspace:

    ``` {.asm code-line-numbers="true"}
    mov	edx,4		; message length
    mov	ecx,msg		; message to write
    mov	ebx,1		; file descriptor (stdout)
    mov	eax,4		; system call number (sys_write)
    int	0x80		; call kernel, switch to ring 0
    ```
::::


:::: {.column .fragment width="50%"}
![](figures/week-2/example_syscall.excalidraw.png){fig-align="center" width=70%}
::::

:::::::


::: {.callout-tip .fragment}
Since the Linux Kernel 2.6, it supports the syscall instruction instead of doing an interrupt 128 (0x80) for syscalls. You can [read more here](
https://scribe.rip/@sachinrajakaruna95/exploring-the-evolution-of-system-call-mechanisms-in-linux-from-int-0x80-to-syscall-e133bb5c151a)
:::

[^1]: 0x80 in hex

## Brief summary:

- If we want to do something related with I/O, or with Operating System Logic, we'll usually ask the kernel for it.

- We talk with the kernel via **syscalls**.

# Processes, threads, and kthreads
- We know how we can communicate with the kernel, but, we're only analyzing 

## Processes, threads, and kthreads
- We know how we can communicate with the kernel, but, we're only analyzing 


- https://linux-kernel-labs.github.io/refs/heads/master/lectures/processes.html#lecture-objectives
- https://dengking.github.io/Linux-OS/Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4.2-Kernel-Threads/
- https://www.man7.org/linux/man-pages/man2/clone.2.html

# ProcFS
Finally, you've been studying

<!-- - https://docs.kernel.org/filesystems/proc.html -->
<!-- - https://github.com/htop-dev/htop/issues/99 -->
<!-- - https://peteris.rocks/blog/htop/ -->

# Quizz

# References

## Really Recommended References: {.smaller}

-   Example: <https://example.com>

-   Example2: <https://example2.com>


## Other recommended references:

-   https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-1.html

## Additional Exercices {.smaller}

If you really want to understand a little bit more what happens under the hood, you can do the following exercices. Be aware that you should read the "Really Recommended References" first, and then try to do this exercices.

-   Create your own syscall: [read this](https://amsa-2425.github.io/Laboratoris/Kernel/add-syscalls.html?highlight=syscall#afegint-una-crida-a-sistema) and [watch this](https://www.youtube.com/watch?v=Kn6D7sH7Fts).

## Activity 2.1 {.smaller}

Ready to have some fun? Check out the [second AMSA activity here!](/activities/act-2.qmd)
