---
subtitle: "Week 3: Scheduling and nice"
format: revealjs
---

# Goals for today

-   Any questions from the previous session?
-   Learn what an scheduler is and why we need it
-   Learn what priority is
-   Learn how we can alter this priority with `nice`
-   Present and explain Prac-2.2

# Scheduler
![](images/paste-1.png){fig-align="center"}

## How does it identify these tasks?{.smaller}
Linux doesn't differenciate between processes and threads, in fact, it has a struct ([task_struct](https://elixir.bootlin.com/linux/v6.16.4/source/include/linux/sched.h#L812)) that is a Kernel descriptor for both threads and processes (tasks). Threads are just tasks sharing resources.

We need a scheduler because we want to run things concurrently, and run more tasks than cores.

## What are priorities? What do they have to do with scheduling?{.smaller}
How do we decide which tasks get CPU time (go into the bar)?

With `priority`, a number tied to each task

- __Range__: -20 (highest priority, most CPU time) to +19 (lowest priority, smallest CPU time)
- __Default__: 0
- Only for __normal (non-real-time)__ processes
- Only for __certain scheduling algorithms__
- Can be __changed__

## How can we change the priority? The `nice` command{.smaller}
When a program is nice, it leaves more time for the other programs, leaving more room to other ones.
By using `nice`, this is exactly what we do, make it "nicer" and alter it's priority.
In fact, the priority Linux Kernel [nice code](https://github.com/coreutils/coreutils/blob/master/src/nice.c#L44) is really simple:
``` {.c}
//...
  ok = (setpriority (PRIO_PROCESS, 0, current_niceness + adjustment) == 0); // Syscall to setpriority
//...
  execvp (argv[i], &argv[i]);
//...
```

## Internal priority and nice priority
Internally, the priority is actually interpreted different, hence the system uses helper functions to translate between these two types of priorities.

``` {.c}
static inline long nice_to_rlimit(long nice)
{
	return (MAX_NICE - nice + 1);
}

/*
 * Convert rlimit style value [1,40] to nice value [-20, 19].
 */
static inline long rlimit_to_nice(long prio)
{
	return (MAX_NICE - prio + 1);
}
```

See more on [the code](https://elixir.bootlin.com/linux/v6.16.4/source/include/linux/sched/prio.h#L28)

# References {.smaller}

-   Linux Scheduling Performance: <https://www.youtube.com/watch?v=8g9fG7cApbc>

-   Create your own linux scheduler with bpf: <https://fosdem.org/2025/schedule/event/fosdem-2025-4620-rust-ifying-the-linux-kernel-scheduler-in-user-space-/>

-   Linux niceness explained: <https://www.youtube.com/watch?v=vd_oGmeoFKs>
## Additional Exercices {.smaller}

If you really want to understand a little bit more what happens under the hood, you can do the following exercices. Be aware that you should read the "References" first, and then try to do this exercises.

-   Implement your own "nice" with Python. Assume all parameters will be correct.

## Activity 2.2 {.smaller}

Ready to have some fun? Check out the second part of the [second AMSA activity here!](/activities/act-2.qmd)