---
subtitle: "Week 10: Dockerfile & DockerHub"
format: revealjs
---

# Goals for today

-   Any questions from the previous session?
-   Dockerfile
-   DockerHub

# Recap

## Let's imagin we have server with lots of resources

::: {style="text-align:center;"}
<img src="figures/week-10/server-0.png" style="width:50%;"/>
:::

## We first deploy a Java app

::: { style="text-align:center;"}
<img src="figures/week-10/server-1.png" style="width:50%;"/>
:::

## Then we add a Python app

::: { style="text-align:center;"}
<img src="figures/week-10/server-2.png" style="width:50%;"/>
:::

## Then we add a React website

::: { style="text-align:center;"}
<img src="figures/week-10/server-3.png" style="width:50%;"/>
:::

## This doesn't scale well..

- We have to make sure permisions and users are properly set up to avoid one app being able to access another app's files.

- What if our Java app requries `OpenSSL 1.1.x` while Python app now requires `OpenSSL 3.x`?

- We need **isolation**!

## We have two options

- **VMs** isolate everything with a full OS per app.
- **Containers** do so while sharing the host kernel.
- **Containers are lighter and faster**, while VMs provide stronger but heavier isolation.

## We'll choose containers

- We'll build a container for each app.
- Each app can have whichever version of packages it wants and can only access its files.
- From the point of view of the app, **it is alone in the server**.

## But how do we build a container for each app?

::: { style="text-align:center;"}
<img src="figures/week-10/server-4.png" style="width:50%;"/>
:::

# Containers

What happens when I run `docker run -it ubuntu bash`?

## Container images

A container runs from an **OCI image**, which contains:

- A root filesystem (the files the app needs)

- A config (environment variables, network, entrypointâ€¦)

- Layers (incremental filesystem changes: adding files, installing packages, etc)

::: {.fragment}
The image provides:
:::

- **What** will run

- **How** it should run (metadata)

## Container runtimes

- The runtime is what interprets the image and **creates the container process**.

- It is the one responsible for **executing the app** inside isolation.

- We'll be using **Docker Engine**.

## The `ubuntu` image

- It is an extremely simple image, built **with only one layer**.

- The Ubuntu developers pack all the file system into an archive and that is the first layer.

::: {.callout-tip .fragment}
We can use `docker inspect <image-name>` to see details of the image, including which layers it has.
:::

## Why is the Ubuntu image only 78MB? {.smaller}

If we do `docker image ls ubuntu`, we'll see it is only 78MB. That is because it includes only the userspace filesystem and essential packages.

::: {.fragment}
It does **not include**:
:::

- kernel
- system services
- drivers
- desktop environment
- init system
- bootloader

::: {.fragment}
A container is not a VM, **it's just a process isolated with its own filesystem**.
:::

# Dockerfile

## Working on top of `ubuntu`

- We've seen how ubuntu image is built with just one layer where all the root filesystem is added.
- But what if I want the image to have additional software?
- `Dockerfile` makes it possible to add layers and customize image config.

## Our first `Dockerfile`

- To get started, we'll need to create a file called `Dockerfile`.
- Inside this file, the first thing is to specify which image are we starting from.

::: {.fragment}
```{.dockerfile}
FROM ubuntu
```
:::

- Now we need to build the image:

::: {.fragment}
```{.bash}
docker build . -t amsa 
# Looks for a Dockerfile in the current directory (.)
# Names the resulting image as amsa
```
:::

## Our first useful `Dockerfile` {.smaller}

The resulting image still has only one layer, which makes sense since there are no changes made to the filesystem.

Let's see an example that makes more sense.

::: {.fragment}
```{.dockerfile}
FROM ubuntu
RUN apt update && apt install figlet
CMD figlet "amsa"
```
:::

- `RUN` keyword lets us execute commands on the base image we are using.
- `CMD` keyword is used to define the default command to be executed when we run a container from this image.

::: {.fragment}
This time, the resulting image will have 2 layers:
:::

- The original layer from `ubuntu` image.
- The one we just added by running a command that modifies the file system.

## Running containers

Once we've built an image, we can use `docker run` command to make Docker Engine execute it.

```{.bash}
$ docker run amsa

  __ _ _ __ ___  ___  __ _
 / _` | '_ ` _ \/ __|/ _` |
| (_| | | | | | \__ \ (_| |
 \__,_|_| |_| |_|___/\__,_|
 ```

::: {.fragment .callout-important}
Adding `-it` to `docker run` command gives the container an interactive terminal by keeping STDIN open (-i) and allocating a TTY (-t).
This is why `docker run -it ubuntu` gives us a bash terminal while `docker run ubuntu` doesn't.
:::


## Sharing files

Let's make `figlet` print the contents of a file instead, a file that resides in our host machine:

- `COPY <src-file> <dst-file>` is used to make our files available to the container.

::: {.fragment}
```{.dockerfile code-line-numbers="4|2|1-4"}
FROM ubuntu
COPY message.txt my-message.txt
RUN apt update && apt install -y figlet
CMD cat my-message.txt | figlet
```
:::

::: {.fragment .callout-warning}
Every time we change the contents of `message.txt`, we'll have to rebuild the image.
:::

## Layer caching

What is the difference between the Dockerfiles below?

```{.dockerfile}
FROM ubuntu
COPY message.txt my-message.txt
RUN apt update && apt install -y figlet
CMD cat my-message.txt | figlet
```
<br>

```{.dockerfile}
FROM ubuntu
RUN apt update && apt install -y figlet
COPY message.txt my-message.txt
CMD cat my-message.txt | figlet
```

::: {.fragment .callout-tip}
The fact that layers are incremental allows for **caching**. If only layer 3 has changed, layer 1 and 2 **do not have to be rebuilt**. This is something we must keep in mind when writing Dockerfiles.
:::

## Working with python

Imagine I have Python project with the following files:

```
â”œâ”€â”€ main.py
â”œâ”€â”€ message.txt      # The message we want pfiglet to print
â”œâ”€â”€ requirements.txt # pyfiglet declared as a dependency
â””â”€â”€ .venv            # The python virtual env
```

Where `main.py` does the following:

```{.python}
from pyfiglet import Figlet

with open("message.txt") as file:
  print(Figlet().renderText(file.read()))
```

## Dockerize our python project {.smaller}

To run my project, I would need to:

```{.bash}
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
python main.py
```

::: {.fragment}
If I want this to happen inside a container, I could create the following Dockerfile:

```{.dockerfile}
FROM python
COPY main.py main.py
COPY message.txt message.txt
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
CMD python main.py
```
:::

::: {.fragment .callout-note}
Why didn't I create a python virtual environment inside the docker container?
:::

## `COPY . .`

- Instead of copying every single file, we'll usually copy our entire working directory.
- `COPY . .` will copy all files on the context directory inside the container.

::: {.fragment}
```{.dockerfile}
FROM python
COPY . .
RUN pip install -r requirements.txt
CMD python main.py
```
:::


## Keeping images small

- When working with containers, we should prioritize the images being **as small as possible**.
- For the container to work, we saw **only** `message.txt`, `main.py` and `requirements.txt` are needed.
- But since we're doing `COPY . .` we're also copying `.venv` and `Dockerfile`, **which are useless inside the container**.

## Dockerignore

- Similar to how `.gitignore` works, we can create a file named `.dockerignore`.
- From the point of view of container we are creating, any file or directory listed inside the `.dockerignore` won't exist.
- For our python project, we could write the following `.dockerignore`:

::: {.fragment}
```{.dockerfile}
.venv/
Dockerfile
.dockerignore
```
:::

## One more change

- What could we still improve for our dockerized Python app? 
- What happens if I only change the `message.txt` file?

::: {.fragment}
```{.dockerfile}
FROM python
COPY . .
RUN pip install -r requirements.txt
CMD python main.py
```
:::

## Remember to use the layer cache

- Real projects will have lots of dependencies, and having to reinstall them **every time a file changes** would be very time consuming.
- It is good practice to first copy only the files needed to install dependencies, and **then copy the rest of the project**:

::: {.fragment}
```{.dockerfile}
FROM python
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD python main.py
```
:::

## Back to the `ubuntu` image

If we had a look at how could the Dockerfile of the `ubuntu` image look like, it could be something like:

```{.dockerfile}
FROM scratch
ADD rootfs-22.04-amd64.tar /
CMD ["/bin/bash"]
```

- `FROM scratch` means we start with an empty image.
- `ADD` works like `COPY` but with added functions, like being able to decompress an archive.
- `CMD ["/bin/bash"]` is very similar to `CMD /bin/bash` [read more here](https://docs.docker.com/reference/dockerfile#shell-and-exec-form).


## Recap {.smaller}

So far we've seen various keywords we can use in Dockerfiles:

- `FROM` â€“ Defines the base image for the build.

- `RUN` â€“ Executes build-time commands.

- `CMD` â€“ Specifies the default runtime command.

- `COPY` â€“ Copies files from the build context into the image.

- `ADD` â€“ Like COPY, but also supports URLs and auto-extracting archives.

::: {.callout-tip .fragment}
Any line in the Dockerfile that modifies the filesystem of the resulting image **creates a new layer**. Thus, All the above keywords can create layers except for `CMD` which is not executed during build-time.
:::

# Container networking

## A simple webserver {.smaller}

- We are going to use Python to run a simple webserver with `python -m http.server <PORT>`. 

- Executing the command will expose files on the current folder through a web interface.

::: {.fragment style="text-align:center;"}
<img src="figures/week-10/python-webserver.png" style="width:70%;"/>
:::

## Containerizing the webserver

A simple Dockerfile that runs the python webserver could be:

```{.dockerfile}
FROM python
CMD ["python", "-m", "http.server", "8080"]
```

::: {.fragment}
We can now build and run the container:

```{.bash}
$ docker build . -t amsa
$ docker run amsa
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
```
:::

::: {.fragment .callout-note}
But how do we access the web server? Visiting `http://localhost:8080/` doesn't work..
:::

## Of course it doesn't work!

- Remember are designed to be isolated.
- Apart from having their own file system, **they also have their own network stack**.
- Port 8080 of the container is not the same as port 8080 of the host machine.

## Mapping ports

- To access services inside containers, **we can map a ports**, that is, "link" a port on our host machine to a port on the container.
- We'll use the `docker run` command to do so by adding the option `-p`:

::: {.fragment}

```{.bash}
$ docker run -it -p 8085:8080 amsa
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
```
:::

- The syntax is `-p HOST_PORT:CONTAINER_PORT`, so with the above example, we would be able to access the webserver on `http://localhost:8085/`


# Container registries

## Columns

Some other nice things are columns:

::::::: columns
:::: {.column .fragment width="50%"}
::: callout-note
#### **Column 1**

-   This uses the first 50% to the left
-   It has also the param fragment so it appears in order
:::
::::

:::: {.column .fragment width="50%"}
::: callout-note
#### **Column 2**

-   This takes the 50% to the right
:::
::::
:::::::

## Tables

| Column 1   | Column 2                                 |
|------------|------------------------------------------|
| **Week 0** | ðŸ“– **Virtualization & Containers** intro |
| **Week 1** | ðŸ“– Explain **PRAC-4.1**                  |

## Smaller slides {.smaller}

-   Adding `{.smaller}` at the end of the slide title makes the entire slide content smaller.

## Figures

As with all elements, adding `.fragment` property will make it appear in order. Also, use `style="text-align:center;"` to center the image or easily do it from the visual editor from vscode.

::: {.fragment style="text-align:center;"}
<img src="figures/week-0/crabs.png" style="width:50%;"/>
:::

# Quizz

## General: {.smaller}

-   Test?

-   Test2?

## Specific part of the theory: {.smaller}

-   q1?

-   q2?

# References

## Really Recommended References: {.smaller}

-   Example: <https://example.com>

-   Example2: <https://example2.com>

## Other References {.smaller}

This section can be difficult to follow. If you're an advanced Linux user and you're interested in exploring the internals, feel free to dive in. Otherwise, it's perfectly fine to skip it for now and come back later (once you feel more comfortable with your operating system and how it works).

-   Example: <https://example.com>

-   Example2: <https://example2.com>

## Additional Exercices {#extra .smaller}

If you really want to understand a little bit more what happens under the hood, you can do the following exercices. Be aware that you should read the "Really Recommended References" first, and then try to do this exercices.

-   Example: <https://example.com>

-   Example2: <https://example2.com>

## Activity 1 {.smaller}

Ready to have some fun? Check out the [second AMSA activity here!](/activities/act-2.qmd)