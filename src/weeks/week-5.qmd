---
subtitle: "Week 5: Memory and Swap"
# bibliography: references/week1.bib
format: revealjs
---

# Goals for today

-   Any questions from the previous session?
-   Understand memory layout of a process
-   Understand Swap
-   Present and explain Prac-3.1

# Recap
-   From zero to Linux
-   Linux concept of a: `task` (prac-2).
-   In the following three sessions we will see:
    - Memory
    - FileSystems

# How does memory work on linux?

-   Each process have a Virtual Address Space.
-   Every Virtual Address Space have "more or less" the same "layout".
-   The `unit` of the Virtual Address Space is a "page".
-   Since every process has his own virtual address space, means that, two processes, can have the same virtual address pointing to a different page!


# Virtual Address space layout

## Layout

![](figures/week-5/virtual-memory-of-process.png){fig-align="center" width="60%"}


## Text Segment {.smaller}

The code (binary) of the program, loaded to RAM.

## Data Segment

That's where global and static variables live, since they will live until the process dies.


::: fragment
``` {.c code-line-numbers="1-6|2"}
// This goes to the data segment of the process VirtualSpace
int my_global_variable = 5;

int main() {
  // Main code here...
}
```
:::


## Stack {.smaller}

Every time we call a function, it pushes it contents to the `stack`. The variables initialized on this function also live inside his stack frame

::::: columns
::: {.column width="50%"}

``` {.c code-line-numbers="1-16|12|1|2|14|5|6|7|8|14|15|16" }
void func_1() {
  float my_var = 0.0f;
}

int func_2() {
  int y = 1;
  int z = 1;
  return y + z;
}

int main() {
  int test = 0;
  func_1();
  test = func_2();
  test = 1;
}
```
:::


::: {.column width="50%"}

<section>
  <img class=fragment code-fragment-index="1" src="figures/week-5/stack-example/1.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="3" src="figures/week-5/stack-example/2.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="4" src="figures/week-5/stack-example/3.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="5" src="figures/week-5/stack-example/4.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="6" src="figures/week-5/stack-example/5.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="7" src="figures/week-5/stack-example/6.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="8" src="figures/week-5/stack-example/7.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="9" src="figures/week-5/stack-example/8.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="10" src="figures/week-5/stack-example/9.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="11" src="figures/week-5/stack-example/10.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
</section>

:::


:::::

# Did we get it? {.smaller}

- Really?
- Sure?

## Stack example, but now with pointers! {.smaller}

Pointers can be scary, but let's see them in action!

::::: columns

::: {.column width="50%"}

``` {.c code-line-numbers="1-15|11|1|2|13|5|6|7|13" }
void func_1(int *x) {
  *x = 1;
}

int func_2() {
  int y = 3;
  return y;
}

int main() {
  int x = 0;
  func_1(&x);
  x = func_2();
  exit(0);
}
```
:::


::: {.column width="50%"}

<section>
  <img class=fragment code-fragment-index="1" src="figures/week-5/stack-pointers/1.png" style="position: absolute; top: 40%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="2" src="figures/week-5/stack-pointers/2.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="3" src="figures/week-5/stack-pointers/3.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="4" src="figures/week-5/stack-pointers/4.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="5" src="figures/week-5/stack-pointers/5.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="6" src="figures/week-5/stack-pointers/6.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="7" src="figures/week-5/stack-pointers/7.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
  <img class=fragment code-fragment-index="8" src="figures/week-5/stack-pointers/8.png" style="position: absolute; top: 20%; left: 60%; width: 30%; height: auto;">
</section>

:::

:::::

# The Heap{.smaller}

## Heap {.smaller}

- If we don’t know how large an array (or whatever data structure) needs to be, or if we need to store data across multiple stack frames, we can use the heap.

- We can allocate memory in this region of the virtual address space and free it when it’s no longer needed.

- Unlike the stack, the heap doesn’t have a fixed size limit (other than available system memory).

## How to allocate memory from the heap

- There are two syscalls `brk/sbrk` and `mmap` for allocating memory and `unmmap` / `brk/sbrk` for deallocating.

- **You'll probably never use the syscalls**, and use the glibc implementation called `malloc` and `free`.

## Example of using Heap memory

::::: columns

::: {.column width="50%"}

``` {.c code-line-numbers="1-15|10|11|1|2|13|5|6|7|13" }
void func_1(int *x) {
  *x = 1;
}

int func_2(int *y) {
  *y = 20;
}

int main() {
  int *var = malloc(sizeof(int));
  *var = 5;
  func_1(var);
  func_2(var);
  free(var);
  // Now the `var` virtual memory address is useless, since we
  // sayed that we want to `free` this memory.
}
```
:::


::: {.column width="50%"}

<section>
  <img class=fragment code-fragment-index="1" src="figures/week-5/heap/1.png" style="position: absolute; top: 20%; left: 50%; width: 50%; height: auto;">
  <img class=fragment code-fragment-index="2" src="figures/week-5/heap/2.png" style="position: absolute; top: 20%; left: 50%; width: 50%; height: auto;">
  <img class=fragment code-fragment-index="3" src="figures/week-5/heap/3.png" style="position: absolute; top: 20%; left: 50%; width: 50%; height: auto;">
  <img class=fragment code-fragment-index="4" src="figures/week-5/heap/4.png" style="position: absolute; top: 20%; left: 50%; width: 50%; height: auto;">
  <img class=fragment code-fragment-index="5" src="figures/week-5/heap/5.png" style="position: absolute; top: 20%; left: 50%; width: 50%; height: auto;">
  <img class=fragment code-fragment-index="6" src="figures/week-5/heap/6.png" style="position: absolute; top: 20%; left: 50%; width: 50%; height: auto;">
  <img class=fragment code-fragment-index="7" src="figures/week-5/heap/7.png" style="position: absolute; top: 20%; left: 50%; width: 50%; height: auto;">
  <img class=fragment code-fragment-index="8" src="figures/week-5/heap/8.png" style="position: absolute; top: 20%; left: 50%; width: 50%; height: auto;">
  <img class=fragment code-fragment-index="9" src="figures/week-5/heap/9.png" style="position: absolute; top: 20%; left: 50%; width: 50%; height: auto;">
</section>

:::

:::::

# What happens if my process allocates a lot of memory?

## Possible solutions {.smaller}

- Linux will first try to free up memory by flushing file-related caches (meaning it writes modified file data from RAM back to disk).

- But what happens if most of the memory was allocated using malloc? In that case, there’s no corresponding file on the filesystem to write this data to! At this point, the system has two options:

  1) Kill the process: The Out-Of-Memory (OOM) killer from the kernel may terminate one or more processes to free up memory.

  2) Use swap space: The kernel can move memory pages to a swap partition or swap file. When a process later needs those pages, a page fault occurs, and the kernel retrieves the data from disk back into RAM.

## Swap Partition vs Swap File {.smaller}

- Swap partition is a partition on the disk that it's occupied only for this cases.

```{.bash}
NAME               MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINTS
nvme0n1            259:0    0 476,9G  0 disk
├─nvme0n1p1        259:1    0   512M  0 part  /boot
├─nvme0n1p2        259:2    0     4G  0 part  [SWAP]
└─nvme0n1p3        259:3    0 472,4G  0 part
  └─crypted        254:0    0 472,4G  0 crypt
    └─root_vg-root 254:1    0 472,4G  0 lvm   /
```

- Swap file: Create a file on your current filesystem.

## How to create a swapfile. {.smaller}

- You can create a swapfile with `mkswap` and activate it with `swapon`.

- Create (do everything as root):

  ```{.bash}
  # dd if=/dev/zero of={full_path_of_swapfile} bs=1MiB count=$((number_of_gb*1024))
  # chmod 0600 {full_path_of_swapfile}
  # mkswap {full_path_of_swapfile}
  ```
- Enable (as root):
  ```{.bash}
  # swapon {full_path_of_the_swapfile}
  ```
- Disable it:
  ```{.bash}
  # swapoff {full_path_of_the_swapfile}
  ```

  ::: {.callout-note title="We have time?"}
  If you want to enable the swapfile every time your machine boots, you can add a [systemd service that enables it](https://wiki.archlinux.org/title/Swap#Swap_file_creation)
  :::

## How to check if a swapfile is working.{.smaller}

- See how much RAM memory do you have on your VM / PC with the `free` command.
- Create a c program that:
  - Allocates (size_of_your_ram + some_arbitrary_number) with the `malloc` glibc function.
  - Use the allocated memory (you can use the `memset` function or a loop for assigning values) [^1] 
- Check with the `free` that swap is being used.

[^1]: This is important because, if you don't use the memory, linux doesn't really allocate the pages.

# Quizz

## Memory

- What happens if I overflow the stack?
- When working with multiple threads (SCP-related), what issues might arise if I pass a reference to a stack-allocated memory chunk?

## Swap

- What happens if I don't have a swap partition/swapile and my memory is full?
- What happens if my swap file is full?

# References

## Really Recommended References: {.smaller}

- Linux Kernel Developer talks about swap: <https://chrisdown.name/2018/01/02/in-defence-of-swap.html>

- Arch Linux Wiki: <https://wiki.archlinux.org/title/Swap>

- Linux Kernel docs talk about swap and hibernation: <https://docs.kernel.org/power/swsusp-and-swap-files.html>

- Swapon syscall definition: <https://elixir.bootlin.com/linux/v6.16.4/source/mm/swapfile.c#L3260>


## Additional Exercices {#extra .smaller}

If you really want to understand a little bit more what happens under the hood, you can do the following exercices. Be aware that you should read the "Really Recommended References" first, and then try to do this exercices.

- Play with the swapiness of your computer: <https://www.ibm.com/docs/en/license-metric-tool/9.2.0?topic=tdad-configuring-swappiness-in-linux-hosting-db2-database-server>

::: {.callout-note title="We have time?"}
Observe how the output of the `free` command changes each time you run `prac-3.1` with different swappiness values (e.g., 0 and 100). Then, create some plots to visualize the differences!
:::


## Activity 3 {.smaller}

Ready to have some fun? Check out the [third AMSA activity here!](/activities/act-3.qmd)
